========
My Story
========
This past year, my employer implemented mandatory computer science classes for students in 6th to 9th grades. I was asked to teach the 6th grade students. There was no curriculum; it was up to me to decide what the students were going to do. For a variety of reasons, I went with Khan Academy. The class was a learning experience for both me and my students. There were some very rough patches throughout the year. Progress on classwork slowed to a crawl. Every educator at one time or another feels that there was more they could have done. This was one of those times. I was lucky that I remained relatively unscathed from the snow days, field trips, and mandatory assemblies. Instead, it was how the content was presented to my students. Often, students were not invested in their work, and when they ran into trouble they were seemingly paralyzed with confusion. The best way to help students was on an individual basis. This means, of course, that students had to wait their turn to get my help. I am a little embarrassed to admit this, but it was not uncommon to have students with their hands raised nearly the entire class, waiting for help that did not come. I managed to come up with a coping mechanism for the remainder of that project. It was not ideal, and the experience was unsatisfactory for both me and my students.

As such, I devoted my capstone project, the culmination of my studies in Emerging Media and Communication, to rethinking how kids are taught to program. What follows are some design principles rooted in my experiences and some oft overlooked ideas from some seminal thinkers on learning to programming.

* Constructionism - get kids building their knowledge as quickly as possible
* Situate the learning as an engaging endeavor
* Readability - not just syntax, but see how ingredients come together
* Helpful error messages - they should point the student toward answer, not despair
* See the state - Elm reactor
* Recomposition/decomposition - everything a function, first-class functions
* Metaphor - not present in project; turtle in Logo, world/big bang in Racket
* Learning Tools - not present in project; design recipe, circles of evaluation, partner

++++++
Theory
++++++
This talk draws on my experiences as an educator and a masters student, as well as the work of Seymour Papert and Bret Victor. Papert is the founder of what would become the MIT Media Lab, the Logo programming language, and constructionism. His most well known work is Mindstorms: Children, Computers, and Powerful Ideas. Papert is a proponent of fundamentally rethinking our approach to education. Victor is a former engineer at Apple, and designed the initial user interface ideas for the iPad and the iPod Nano. Since leaving Apple, Victor has looked at how we learn to program and programming in general with a critical eye. His talks Inventing on Principle and The Future of Programming are well worth your time, but I am pulling from his article Learnable Programming for this talk.

++++++++
Overview
++++++++
I have identified eight design principles that I believe make learning to program more accessible to beginner students.

++++++++++++++++++++++++++++++++++++++++++
Constructionism - Immediacy of Interaction
++++++++++++++++++++++++++++++++++++++++++
Constructionism is the foundational idea of Seymour Papert. As a student of famed Swiss developmental psychologist Jean Piaget, Papert took Piaget’s idea of Constructivism and adapted it to more concrete, tangible ideas. Both Piaget and Papert believe that students must interact with the world around them and construct knowledge through these interactions. Papert diverted from Piaget in that he wants students to build something tangible with these interactions, whereas Piaget focused on the construction of abstract ideas. If you require the student to spend a substantial amount of time listening to a lecture, reading a lesson, or watching a video, then you are delaying the interaction between student and code. No matter how beneficial you may believe these instructional aids to be, you are withholding knowledge because there is no interaction. There needs to be an immediacy to the interaction. Without it, according to Papert, there can be no knowledge.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Situate the Learning - Build the Thing You Want to Build
++++++++++++++++++++++++++++++++++++++++++++++++++++++++
When I first learned to program, I started with the ubiquitous Hello World. In 2015, text manipulation doesn’t pique the interest of students. So we have moved onto shapes; the rectangle is the first thing a student codes. However, I have never worked with a student who proclaims to want to draw shapes. They have bigger ideas for what they want to create. Often they want to make an app or a game. Having an engaged student is wonderful from an educator’s point of view. Why, then, do we insist on dismantling this enthusiasm by having students make shapes and other objectives directly related to the game they want to make? Most likely, it is because we have all learned to program this way. Build small, simple things. Each one is a little more complex than the previous. However, there is no real relationship between them. Papert calls this the QWERTY problem; if we do something long enough, then we assume that this is the natural or best way of doing things. The QWERTY keyboard came about because this configuration spaced out the most used keys on a typewriter. Thus, this limited the amount of times that a typewriter would get jammed. We no longer use typewriters, there is nothing to get jammed. But, we have come to think that the QWERTY keyboard is the “normal” or “best” keyboard. If we want students learn to program and they want to make a game, then why waste their time on unrelated tasks? Learning should be situated in the appropriate subject matter. Get students building the thing they want to build. 

+++++++++++
Readability
+++++++++++
Ostensibly, readability is making sense of the code. Can a beginner understand what the code means? For my capstone project, I chose Elm as the programming language. One reason Elm appealed to me is that it compiles down to JavaScript, HTML, and CSS. This, of course, is nothing new. Plenty of other languages do the same thing. The idea behind languages like Elm makes for a more beginner friendly approach. How readable can a language be if the properties of the HTML elements are in another file? With Elm, there are no other files with which you must consult. However, you can say the same thing about many other programming languages. Beginners are not required to start off with web languages. Elm made some interesting syntactic choices. In my capstone project, I guide students toward the beginnings of a simple video game. Here is the code to make a circle (SLIDE). Elm’s use of infix operators makes the code easier to read. It is a circle with a list of attributes. Having each attribute on its own line increased readability. Here is an example of elements flowing down (SLIDE). The creator of Elm encourages a specific style guide in which the commas are aligned with the square brackets. This is a nice visual touch that increases readability. 

Readability, however, is not just being able to read the code. Readability is also understanding what it is that the code does. Why is this code important? In my capstone project, I try to convey meaning by providing a summary of what the code does when the user hovers over the code example (DEMO). The idea is to provide context as why the user needs this code. My goal is to give the user the foundation of a game, but if they do not understand how the lines of code work together, there is no way that they can expand upon the game to make it fun and interesting. Beginners need both a macro and micro understanding of what the code. What does it do in this particular instance? Draw a circle, fill the circle with a color, call another function, etc. And they need to understand how the code fits into the larger picture. If they want to add a second bad guy, then the user had better understand the code that governs the first bad guy.

++++++++++++++++++++++
Helpful Error Messages
++++++++++++++++++++++
Lack of knowledge and experience are the defining characteristics of beginners. As such, they will make mistakes. Error messages, in theory, are supposed to help users fix the mistakes in their code. I have come to realize that not all error messages are the same. I have a student who is in 5th grade. Last year he came to me and said that he would like to learn how to write apps for his Android tablet. I told him that I did not know how to do that. I had heard of Android App Inventor, and I invited the student to come by the lab before school to work on it. One day he said that he ran into a problem, and could not figure out the error. He logged into his account, ran his program, and showed me this error message (SLIDE). Now, Android App Inventor has its roots in Scratch, the block-based, drag and drop programming language. It is supposed to be the most beginner friendly way to write apps for Android. And yet the student got this. How does this help the user? How could he not feel frustrated? Error messages should point the user toward the resolution. Even more thought out environments like Khan Academy have problems with their error messages. Here (SLIDE) above is some code for a for-loop. Below is the error message. The problem is that users will read the error literally. Users will look to add a comma to their code when in fact they need to add a closing curly brace.

Since version 0.15, Elm is making useful error messages a priority. Here (SLIDE) is an example of some bad code. I have a variable called “sum” that has the value of 2 + 2. In Elm, you have to have a “main” function. So I have a “main” and I assign it the value of “sum.” This (SLIDE) is the error message I get. Not bad. It is much more verbose than Khan Academy, and it is pretty clear what the problem is. So let’s rewrite that bit of Elm code (SLIDE). I need this “element” thing, so I imported the Graphics.Element library. I specify the type signature of “main” as of type Element, and I once again assign the value of “sum” to “main.” When I compile the code, this is what I get (SLIDE). Again, I get a nice verbose message. Even though I imported the library and set the type signature, I still have the same problem. But notice, Elm does not give me the same error message. It goes on to specify that the compiler expects “main” to have a type of Element, but that I am giving “main” something of the type number. Now I can narrow down my search to “sum.” I also like the “Jump to error” link in the error message. When I click on that (SLIDE) see where the compiler is having a problem. Up above, there is a hint. That link will take me to the Elm documentation so I can read through API to figure out how to resolve the issue.

While I would not call Elm’s error messages to be perfect, they are more helpful than other options out there. When teaching kids to code, they need error messages that help rather than hinder.

+++++++++++++
See the State
+++++++++++++

+++++++++++++++++++++++++++
Recomposition/Decomposition
+++++++++++++++++++++++++++

++++++++
Metaphor
++++++++

++++++++++++++
Learning Tools
++++++++++++++

e261b0fae09219def2b70b01867683b6
